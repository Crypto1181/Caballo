<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lightweight Chart</title>
  <style>
    html, body { height: 100%; margin: 0; background: transparent; }
    #chart { position: absolute; left: 0; top: 0; right: 0; bottom: 0; }
  </style>
  <!-- TradingView Lightweight Charts - Official Library -->
  <script src="https://unpkg.com/lightweight-charts@5.0.9/dist/lightweight-charts.standalone.production.js"></script>
</head>
<body>
  <div id="chart"></div>
  <script>
    const container = document.getElementById('chart');
    let chart, candleSeries, volumeSeries;
    let currentType = 'candlestick';

    function create(options) {
      const defaultOptions = {
        layout: { background: { type: 'solid', color: 'transparent' }, textColor: options && options.dark ? '#ffffff' : '#222222' },
        grid: { vertLines: { color: options && options.dark ? '#222' : '#eee' }, horzLines: { color: options && options.dark ? '#222' : '#eee' } },
        rightPriceScale: { borderVisible: false },
        timeScale: { borderVisible: false },
        crosshair: { mode: 1 },
        autoSize: true,
      };
      chart = LightweightCharts.createChart(container, Object.assign({}, defaultOptions, options || {}));
      const type = (options && options.type) || 'candlestick';
      currentType = type;
      if (type === 'line') {
        candleSeries = chart.addSeries(LightweightCharts.LineSeries, (options && options.series) || {});
      } else if (type === 'area') {
        candleSeries = chart.addSeries(LightweightCharts.AreaSeries, (options && options.series) || {});
      } else {
        candleSeries = chart.addSeries(LightweightCharts.CandlestickSeries, (options && options.series) || {});
      }
      volumeSeries = chart.addSeries(LightweightCharts.HistogramSeries, {
        priceScaleId: '', // separate pane under chart
        priceFormat: { type: 'volume' },
        priceLineVisible: false,
        color: options && options.dark ? '#5e81ac' : '#4f6fd8',
        ...((options && options.volumeSeries) || {}),
      });
      chart.priceScale('').applyOptions({ scaleMargins: { top: 0.8, bottom: 0 } });
    }

    // Flutter calls this: data = candles[], volume = volume[]
    window.initChart = function(data, options, volume) {
      if (!chart) create(options);
      if (!candleSeries || !volumeSeries) return;
      candleSeries.setData(Array.isArray(data) ? data : []);
      if (Array.isArray(volume)) volumeSeries.setData(volume);
      if (options && options.fit && chart && chart.timeScale) chart.timeScale().fitContent();
    }

    // Change series type at runtime
    window.setSeriesType = function(type, seriesOptions) {
      if (!chart) return;
      const data = candleSeries ? candleSeries.data() : [];
      try { chart.removeSeries(candleSeries); } catch(e) {}
      currentType = type;
      if (type === 'line') {
        candleSeries = chart.addSeries(LightweightCharts.LineSeries, seriesOptions || {});
      } else if (type === 'area') {
        candleSeries = chart.addSeries(LightweightCharts.AreaSeries, seriesOptions || {});
      } else {
        candleSeries = chart.addSeries(LightweightCharts.CandlestickSeries, seriesOptions || {});
      }
      if (Array.isArray(data) && data.length) candleSeries.setData(data);
    }

    // Add/replace markers
    window.setMarkers = function(markers) {
      if (!candleSeries) return;
      try { candleSeries.setMarkers(Array.isArray(markers) ? markers : []); } catch(e) {}
    }

    // Update/append a bar and volume in real-time
    window.updateBar = function(bar, volBar) {
      if (!candleSeries) return;
      if (currentType === 'candlestick') {
        candleSeries.update(bar);
      } else {
        // for line/area, map close to value
        candleSeries.update({ time: bar.time, value: bar.close });
      }
      if (volumeSeries && volBar) volumeSeries.update(volBar);
    }

    // Real-time price tick updates (update latest bar with current price)
    window.updatePrice = function(tick) {
      if (!candleSeries || !tick) return;
      const data = candleSeries.data();
      if (data.length === 0) return;
      const latest = data[data.length - 1];
      const now = tick.time || Math.floor(Date.now() / 1000);
      const prevTime = currentType === 'candlestick' ? latest.time : latest.time;
      // If same bar time, update the latest bar
      if (now === prevTime) {
        if (currentType === 'candlestick') {
          candleSeries.update({ time: latest.time, open: latest.open, high: Math.max(latest.high, tick.price), low: Math.min(latest.low, tick.price), close: tick.price });
        } else {
          candleSeries.update({ time: latest.time, value: tick.price });
        }
      }
    }
  </script>
  </body>
  </html>


